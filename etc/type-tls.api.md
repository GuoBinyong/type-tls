## API Report File for "type-tls"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AnyFunction = (...args: any) => any;

// @public
export interface ClassType<Arg extends any[] = any[], Instance = any> {
    	// (undocumented)
    new (...args: Arg): Instance;
}

// @public
export function createDefineMixin<T>(): <M>(target: T, mixin: M & ThisType<T & M>) => M & ThisType<T & M>;

// @public
export function createExtendTarget<C extends ClassType>(cla: C): <E>(ext: E & ThisType<InstanceType<C> & E> & PrivateMemberOfExtend<C>) => ClassType<ConstructorParameters<C>, E & ThisType<InstanceType<C> & E>>;

// @public
export function createMixinTarget<T>(target: T): <M>(m: M & ThisType<T & M>) => M & ThisType<T & M> & T;

// @public
export function createTargetExtend<C extends ClassType>(cla: C): <E>(ext: E & ThisType<InstanceType<C> & E> & PrivateMemberOfExtend<C>) => E & ThisType<C & E>;

// @public
export function createTargetMixin<T>(target: T): <M>(m: M & ThisType<T & M>) => M & ThisType<T & M>;

// @public
export function defineExtend<C extends ClassType, E>(cla: C, ext: E & ThisType<InstanceType<C> & E> & PrivateMemberOfExtend<C>): E & ThisType<C & E>;

// @public
export function defineMixin<T, M>(target: T, mixin: M & ThisType<T & M>): M & ThisType<T & M>;

// @public
export type ExactType = LooseType | Exclude<TypeOfReturnType, "undefined" | "function" | "object">;

// @public
export type ExactTypeName = LooseTypeName | Exclude<TypeOfReturnType, "undefined" | "function" | "object">;

// @public
export function extendTarget<C extends ClassType, E>(cla: C, ext: E & ThisType<InstanceType<C> & E> & PrivateMemberOfExtend<C>): ClassType<ConstructorParameters<C>, E & ThisType<InstanceType<C> & E>>;

// @public
export function getExactTypeNameOf(inst: any): ExactTypeName;

// @public
export function getExactTypeOf(inst: any): ExactType;

// @public
export function getNameOfType(t: ExactType): ExactTypeName;

// @public
export function getTypeByName(typeName: string): Function | undefined;

// @public
export function getTypeNameOf(inst: any): LooseTypeName;

// @public
export function getTypeOf(inst: any): LooseType;

// @public
export function isAnonymousFunction(fun: Function): boolean;

// @public
export function isArrayLike(target: any): boolean;

// @public
export function isArrowFunction(fun: Function): boolean;

// @public
export function isAsyncFunction(fun: Function): boolean;

// @public
export function isAsyncGeneratorFunction(fun: Function): boolean;

// @public
export function isBaseType(data: any): boolean;

// @public
export function isGeneratorFunction(fun: Function): boolean;

// @public
export function isIdentifier(code: string): boolean;

// @public
export function isIterable(target: any): boolean;

// @public
export function isIterator(target: any): boolean;

// @public
export function isObject(target: any): boolean;

// @public
export type KeyOfValue<Target, Value> = {
    	[K in keyof Target]: Target[K] extends Value ? K : never;
}[keyof Target];

// @public
export type LooseType = undefined | null | Function | "object";

// @public
export type LooseTypeName = "undefined" | "null" | "Function" | "object" | string;

// @public
export type MethodParams<Obj, Method extends keyof Obj, ParamIndex extends number> = Obj[Method] extends AnyFunction ? Parameters<Obj[Method]>[ParamIndex] : never;

// @public
export type MethodReturnType<Obj, Method extends keyof Obj> = Obj[Method] extends AnyFunction ? ReturnType<Obj[Method]> : never;

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "mixin" because one of its declarations is marked as @internal
//
// @internal
export function mixin<T, S>(target: T, source: S): T & S;

// @internal
export function mixin<T, S1, S2>(target: T, source1: S1, source2: S2): T & S1 & S2;

// @internal
export function mixin<T, S1, S2, S3>(target: T, source1: S1, source2: S2, source3: S3): T & S1 & S2 & S3;

// @internal
export function mixin<T, S1, S2, S3, S4>(target: T, source1: S1, source2: S2, source3: S3, source4: S3): T & S1 & S2 & S3 & S4;

// @public
export function mixin(target: any, ...sources: any[]): any;

// @public
export function mixinTarget<T, M>(target: T, m: M & ThisType<T & M>): M & ThisType<T & M> & T;

// @public
export type Optional<T> = T | null | undefined;

// @public
export type OptionalBoolean = Optional<boolean>;

// @public
export interface PrivateMemberOfExtend<TargetType extends new (...args: any) => any> {
    	_constructor?: (...args: (TargetType extends new (...args: infer A) => any ? A : never)) => void;
}

// @public
export type Replace<SourType, MatchType, NewType> = SourType extends MatchType ? NewType : SourType;

// @public
export type ReplaceNull<SourType, NewType> = Replace<SourType, null, NewType>;

// @public
export type ReplaceUndefined<SourType, NewType> = Replace<SourType, undefined, NewType>;

// @public
export type ReplaceVoid<SourType, NewType> = Replace<SourType, void | undefined | null, NewType>;

// @public
export type ResolveData<P> = P extends Promise<infer D> ? D : P;

// @public
export function targetExtend<C extends ClassType, E>(cla: C, ext: E & ThisType<InstanceType<C> & E> & PrivateMemberOfExtend<C>): E & ThisType<InstanceType<C> & E>;

// @public
export function targetMixin<T, M>(target: T, m: M & ThisType<T & M>): M & ThisType<T & M>;

// @public
export type TypeOfReturnType = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";

// @public
export function waitAsyncable<Result, Return>(asyncable: Result, callback: WaitAsyncableCallback<Result, Return>): WaitAsyncableReturn<Result, Return>;

// @public
export type WaitAsyncableCallback<Result, Return> = (result: ResolveData<Result> | undefined, rejected: boolean, error: any) => Return;

// @public
export type WaitAsyncableReturn<Result, Return> = Return extends Promise<any> ? Return : (Result extends Promise<any> ? Promise<Return> : Return);

```
